# -*- coding: utf-8 -*-
"""dynamic_calculation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13cqt3gdtfYAgyf-4Tvcg9XPeQiC80yjb

##**Dynamic Response Calculation: Simple Spring QZS device** ##
"""

import numpy as np
import matplotlib.pyplot as plt

peak_f = []
isolation_f = []

# Geometric parameters of the Simple Spring QZS device
l_0 = 70
l = 70-24
k_v = 2
k_h = 1.86
m = 4

k1 = k_v - 2*((l_0/l)-1)*k_h # Overall stiffness
k3 = (l_0/(l**3))*k_h #cubic stiffness term
alpha = k1/k_v
x_s = (l_0**2 - l**2)**(0.5)

damping = 0.25 # DAMPING RATIO
gamma = (k3*x_s**2)/k_v # NONLINEARITY PARAMETER

# Max allowable excitation magnitude
X_max = x_s*4*damping*((1-alpha)/(3*gamma))**0.5
print(x_s)

# Geometric parameters of the SBS QZS device
l_0 = 55
l = 55-36.6
k_v = 2
k_h = 1.1
m = 4
a = k_h/k_v

gamma2 = 1.08
gamma1 = 0.74667

alpha = 1-2*a*((1-gamma2)/gamma1 + 1)
gamma = (-a*(1-gamma2))/gamma1**3

x_s = l_0
print(x_s)

damping = 0.05 # DAMPING RATIO

# Max allowable excitation magnitude
X_max = 4*damping*((1-alpha)/(3*gamma))**0.5

# Geometric parameters of the CRS QZS device

l_0 = 55
l = 55-23.214
k_v = 2
k_h = 1.1
m = 4
a = k_h/k_v

d = 26/(2*a)
delta = d/26
x_s = 26

alpha = 1-2*a*delta
gamma = -a*(delta - 1)
damping = 0.1 # DAMPING RATIO
xe = 5
X_e = xe/26'''

len = 10

z1 = np.zeros((len,)); z2 = np.zeros((len,)); z3 = np.zeros((len,)); z4 = np.zeros((len,)); z5 = np.zeros((len,))
Z_max = np.zeros((len,))

Sum1 = np.zeros((len,1000))
Sum2 = np.zeros((len,1000))
Sum3 = np.zeros((len,1000))

Omega1 = np.zeros((len,1000))
Omega2 = np.zeros((len,1000))

cos1 = np.zeros((len,1000))
cos2 = np.zeros((len,1000))
T_d1 = np.zeros((len,1000))
T_d2 = np.zeros((len,1000))

isolation = np.zeros((len,1000))
peak_freq = np.zeros((len,))

colour = ["red","orange","blue","grey","green","orange","orange","orange","grey","grey"]

xe = 1
amplitude = []

for i in range(0,6):

  # Initialize damping and excitation amplitude, the damping ratio must be such that the system response remains bounded at the resonant frequency
  print(x_s)
  X_e = xe/x_s
  damping = np.sqrt((3*gamma*X_e**2)/16)+0.05
  amplitude.append(xe)

  # Calculating the maximum displacement response Z_max given the parameters
  z1[i] = (3*alpha*gamma*X_e**2)/(4*damping**2)
  z2[i] = 2*damping*(damping + (alpha/damping))
  z3[i] = ((3*alpha*gamma*X_e**2)/(4*damping**2))
  z4[i] = (damping - (alpha/damping))**2
  z5[i] = 3*gamma*X_e**2*(1-((3*gamma *X_e**2)/(16*damping**2)))
  Z_max[i] = np.sqrt(((z1[i] + z2[i]) - 2*damping * np.sqrt((z3[i] + z4[i])))/z5[i])+15

  # Calculate the displacement response across a range of frequencies, max dispalcement response should not exceed Z_max
  Z_hat = np.linspace(0.1,Z_max[i],1000)
  Sum1[i] = (((3/4)*gamma*X_e**2*Z_hat**2 + alpha)*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 4*Z_hat**2*damping**2)+4*Z_hat**2*damping**4)
  Sum2[i] = ((Z_hat**2*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 2*damping**2)) + Z_hat*(Sum1[i]**0.5))/(Z_hat**2 - 1)
  Sum3[i] = ((Z_hat**2*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 2*damping**2)) - Z_hat*(Sum1[i]**0.5))/(Z_hat**2 - 1)

  # Obtain the two branches of the curve
  Omega1[i] = np.sqrt(Sum2[i])
  Omega2[i] = np.sqrt(Sum3[i])

  # Convert from displacement response to displacement transmissibility
  cos1[i] = ((3/4)*X_e**2*gamma*Z_hat**3 +(alpha - Omega1[i]**2)*Z_hat)/(Omega1[i]**2)
  cos2[i] = ((3/4)*X_e**2*gamma*Z_hat**3 +(alpha - Omega2[i]**2)*Z_hat)/(Omega2[i]**2)

  # Displacement Transmissibility
  T_d1[i] = (1+2*Z_hat*cos1[i] + Z_hat**2)**0.5
  T_d2[i] = (1+2*Z_hat*cos2[i] + Z_hat**2)**0.5

  # Isolation frequency & Peak frequency
  for j in range(0,1000):
    # Isolation frequency
    if abs(T_d1[i][j])-1 <= 0.005:
      isolation[i] = Omega1[i][j]
    # Peak frequency
    if T_d1[i][j] == max(T_d1[i]):
      peak_freq[i] = Omega1[i][j]
    elif T_d2[i][j] == max(T_d2[i]):
      peak_freq[i] = Omega2[i][j]

  plt.plot(Omega2[i], T_d2[i],color = colour[i],label=f"Excitation = {xe:.2f}mm   $\zeta$ = {damping:.3f}")
  plt.plot(Omega1[i], T_d1[i],color = colour[i])

  xe += 1

isolation_freq = np.zeros((10,))
for i in range(10):
  isolation_freq[i] = isolation[i][0]

print("Isolation frequency:", isolation_freq)
print("Jump frequency:", peak_freq)


# Plot for a linear system
l_0 = 70
l = 70
k_v = 2
k1 = k_v
k3 = (l_0/(l**3))*k_h
alpha = k1/k_v
x_s = (l_0**2 - l**2)**(0.5)
X_e = 0.4
damping = 0.065
gamma = (k3*x_s**2)/k_v
# Max allowable excitation magnitude
Z_hat = np.linspace(0.1,70,1000)
Sum1 = (((3/4)*gamma*X_e**2*Z_hat**2 + alpha)*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 4*Z_hat**2*damping**2)+4*Z_hat**2*damping**4)
Sum2 = ((Z_hat**2*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 2*damping**2)) + Z_hat*(Sum1**0.5))/(Z_hat**2 - 1)
Sum3 = ((Z_hat**2*((3/4)*gamma*X_e**2*Z_hat**2 + alpha - 2*damping**2)) - Z_hat*(Sum1**0.5))/(Z_hat**2 - 1)
Omega1 = np.sqrt(Sum2)
Omega2 = np.sqrt(Sum3)

# Convert from displacement response to displacement transmissibility
cos1 = ((3/4)*X_e**2*gamma*Z_hat**3 +(alpha - Omega1**2)*Z_hat)/(Omega1**2)
cos2 = ((3/4)*X_e**2*gamma*Z_hat**3 +(alpha - Omega2**2)*Z_hat)/(Omega2**2)

# Displacement Transmissibility
T_d1 = (1+2*Z_hat*cos1 + Z_hat**2)**0.5
T_d2 = (1+2*Z_hat*cos2 + Z_hat**2)**0.5

plt.plot(Omega2, T_d2,color = "black", label="Linear System")
plt.plot(Omega1, T_d1,color = "black")
print("Linear curve: ", X_e)

plt.title("Transmissibility Curve")
plt.xlabel("Frequency ratio $\Omega = \omega/\omega_n$")
plt.ylabel("Displacement Transmissibility")
plt.yscale("log")
plt.xscale("log")
plt.legend()
plt.grid()
plt.show()

# Damping bounds
print((3*gamma*X_e**2)/(16*damping**2))
print(peak_freq)

# Determine frequency at which isolation occurs

isolation_frequency = np.zeros((10,))
linear_freq = np.full(10,np.sqrt(2))

for i in range(10):
  if peak_freq[i] >= isolation_freq[i]:
    isolation_frequency[i] = peak_freq[i]
  else:
    isolation_frequency[i] = isolation_freq[i]

print(isolation_freq)
print(peak_freq)
print(isolation_frequency)
print(amplitude)

# Data storage system

peak_f.append(peak_freq)
isolation_f.append(isolation_f)

print(peak_f)
print(isolation_f)

'''# Plotting the relationship of isolation frequency to amplitude of excitation

device = ["Simple spring","SBS","CRS"]
damping_ratio = [0.22, 0.05, 0.03]

for i in range(0,3):
  plt.plot(amplitude,peak_f[i],label = f"{device[i]}, $\zeta$ = {damping_ratio[i]:.3f}")

plt.plot(amplitude,linear_freq,label = f"Linear system")

plt.xlabel("Excitation Amplitude (mm)")
plt.ylabel("Frequency Ratio $\Omega_I$")
plt.title(f"Isolation Frequency at $\zeta$ = {damping:.3f}")
plt.ylim(0,1.6)
plt.xlim(0,20)

plt.legend()
plt.grid()
plt.show()'''

"""## Comparison of the 3 QZS device ##

The transmissibility curves of the three devices will be compared.

"""

d = 26/(2*0.56)
delta = d/26
gamma2 = 1.08
gamma1 = 0.74667
damping = 0.01

k_v = np.array([2,2,2])
k_h = np.array([1.8,1.1,1.1])
a = np.array([k_h[0]/k_v[0],k_h[1]/k_v[1],k_h[2]/k_v[2]])
nd = np.array([x_s,26,55])

alpha_val = np.array([(k1/2), 0, (1-2*a[2]*((1-gamma2)/gamma1 + 1))])
gamma_val = np.array([(k3*x_s**2)/2, -a[1]*(delta - 1), (-a[2]*(1-gamma2))/gamma1**3])

print(np.shape(alpha_val))
print(np.shape(gamma_val))

colour = ["red","blue","green"]
labels = ["simple spring", "CRS", "SBS"]

X_e = 0
xe = 10

Sum1 = np.zeros((3,1000))
Sum2 = np.zeros((3,1000))
Sum3 = np.zeros((3,1000))
print(np.shape(Sum3[1]))
damping_ratio = [0.12,0.0415,0.03]

for i in range(0,3):

  # Initialize damping and excitation amplitude, the damping ratio must be such that the system response remains bounded at the resonant frequency
  if i == 0:
    X_e = xe/x_s
  elif i == 1:
    X_e = xe/26
  else:
    X_e = xe/55

  damping = damping_ratio[i]#np.sqrt((3*gamma_val[i]*X_e**2)/16)+0.01

  # Calculating the maximum displacement response Z_max given the parameters
  z1[i] = (3*alpha_val[i]*gamma_val[i]*X_e**2)/(4*damping**2)
  z2[i] = 2*damping*(damping + (alpha_val[i]/damping))
  z3[i] = ((3*alpha_val[i]*gamma_val[i]*X_e**2)/(4*damping**2))
  z4[i] = (damping - (alpha_val[i]/damping))**2
  z5[i] = 3*gamma_val[i]*X_e**2*(1-((3*gamma_val[i] *X_e**2)/(16*damping**2)))
  Z_max[i] = np.sqrt(((z1[i] + z2[i]) - 2*damping * np.sqrt((z3[i] + z4[i])))/z5[i])+25

  # Calculate the displacement response across a range of frequencies, max dispalcement response should not exceed Z_max
  Z_hat = np.linspace(0.1,Z_max[i],1000)

  print(np.shape(Z_hat))
  Sum1[i] = (((3/4)*gamma_val[i]*X_e**2*Z_hat**2 + alpha_val[i])*((3/4)*gamma_val[i]*X_e**2*Z_hat**2 + alpha_val[i] - 4*Z_hat**2*damping**2)+4*Z_hat**2*damping**4)
  Sum2[i] = ((Z_hat**2*((3/4)*gamma_val[i]*X_e**2*Z_hat**2 + alpha_val[i] - 2*damping**2)) + Z_hat*(Sum1[i]**0.5))/(Z_hat**2 - 1)
  Sum3[i] = ((Z_hat**2*((3/4)*gamma_val[i]*X_e**2*Z_hat**2 + alpha_val[i] - 2*damping**2)) - Z_hat*(Sum1[i]**0.5))/(Z_hat**2 - 1)

  # Obtain the two branches of the curve
  Omega1[i] = np.sqrt(Sum2[i])
  Omega2[i] = np.sqrt(Sum3[i])

  # Convert from displacement response to displacement transmissibility
  cos1[i] = ((3/4)*X_e**2*gamma_val[i]*Z_hat**3 +(alpha_val[i] - Omega1[i]**2)*Z_hat)/(Omega1[i]**2)
  cos2[i] = ((3/4)*X_e**2*gamma_val[i]*Z_hat**3 +(alpha_val[i] - Omega2[i]**2)*Z_hat)/(Omega2[i]**2)

  # Displacement Transmissibility
  T_d1[i] = (1+2*Z_hat*cos1[i] + Z_hat**2)**0.5
  T_d2[i] = (1+2*Z_hat*cos2[i] + Z_hat**2)**0.5

  plt.plot(Omega2[i], T_d2[i],color = colour[i], label=labels[i]+f" $\zeta$ = {damping:.3f}")
  plt.plot(Omega1[i], T_d1[i],color = colour[i])

plt.title(f"Transmissibility Curve Comparison (Excitation Amplitude $X_e$ = {xe:.2f}) mm")
plt.xlabel("Frequency ratio $\Omega = \omega/\omega_n$")
plt.ylabel("Displacement Transmissibility")
plt.yscale("log")
plt.xscale("log")
plt.legend()
plt.grid()
plt.show()

"""## Error Estimation ##

Since the parameters $\alpha$ and $\gamma$ are obtained through Taylor series approximation, the error is calculated.

**Simple Spring QZS Device**
"""

x = np.linspace(-1.5,1.5,300)

l_0 = 70
l = 70-24
k_v = 2
k_h = 1.86
m = 4
a = k_h/k_v
l_hat = l/l_0

x_s = np.sqrt(l_0**2 - l**2)

# True value
f = x + 2*a*x*(1-1/(np.sqrt(x**2*(1-l_hat**2)+l_hat**2)))

# Approximate value
alpha_ss = 1-2*a*((1-l_hat)/l_hat)
gamma_ss = a*((1-l_hat**2)/l_hat**3)

f_approx = alpha_ss*x + gamma_ss*x**3

# Displacement range of analysis
lim_ss = 17/x_s

plt.plot(x,f,label = "True Curve")
plt.plot(x,f_approx,label = "Taylor series approximation curve")
plt.axvspan(-lim_ss, lim_ss, color = "green", alpha = 0.2, label = "Range of analysis")
plt.ylabel("Non-dimensional Force")
plt.xlabel("Non-dimensional displacement")
plt.xlim(-0.5,0.5)
plt.ylim(-0.1,0.1)
plt.legend()
plt.title("Simple Spring device approximation error")
plt.show()

error_ss = []
# Maximum error
for i in range(299):
  if abs(x[i] - lim_ss) <= 0.01:
    e = (abs(f_approx[i] - f[i])/f[i])
    error_ss.append(e)

print(error_ss)

"""**CRS QZS Device**"""

x = np.linspace(-1.5,1.5,300)
d = 26/(2*0.56)
delta = d/26
a = 0.56

# True values
f = x - 2*a*x*(1+(delta-1)/np.sqrt(1-x**2))

# Approximated values
f_approx = -a*(delta-1)*x**3

# Displacement range of analysis
lim_crs = 17/26

plt.plot(x,f,label = "True Curve")
plt.plot(x,f_approx,label = "Taylor series approximation curve")
plt.axvspan(-lim_crs, lim_crs, color = "green", alpha = 0.2, label = "Range of analysis")
plt.ylabel("Non-dimensional Force")
plt.xlabel("Non-dimensional displacement")
plt.xlim(-1.5,1.5)
plt.ylim(-0.1,0.1)
plt.legend()
plt.title("CRS device approximation error")
plt.show()

error_crs = []
# Maximum error
for i in range(299):
  if abs(x[i] - lim_crs) <= 0.01:
    e = abs(f_approx[i] - f[i])/f[i]
    error_crs.append(e)

print(error_crs)

# Error curve
x = np.linspace(-lim_crs,lim_crs,500)
d = 26/(2*0.56)
delta = d/26
a = 0.56

f2 = (x - 2*a*x*(1+(delta-1)/np.sqrt(1-x**2)))
f_approx2 = (-a*(delta-1)*x**3)
e2 = (abs(f_approx2 - f2)/f2)*100

plt.plot(x,e2)
plt.xlabel("Excitation amplitude")
plt.ylabel("Error(%)")
plt.grid()
plt.show()

"""**SBS QZS Device**"""

x = np.linspace(-1.5,1.5,300)

l_0 = 55
l = 55-36.6
k_v = 2
k_h = 1.1
m = 4
a = k_h/k_v

gamma2 = 1.08
gamma1 = 0.74667

alpha = 1-2*a*((1-gamma2)/gamma1 + 1)
gamma = (-a*(1-gamma2))/gamma1**3

# True values
f = x - 2*a*x*((1-gamma2)/np.sqrt(gamma1**2 - x**2) + 1)

# Approximated values
f_approx = alpha*x + gamma*x**3

# Displacement range of analysis
lim_sbs = 17/l_0

plt.plot(x,f,label = "True Curve")
plt.plot(x,f_approx,label = "Taylor series approximation curve")
plt.axvspan(-lim_sbs, lim_sbs, color = "green", alpha = 0.2, label = "Range of analysis")
plt.ylabel("Non-dimensional Force")
plt.xlabel("Non-dimensional displacement")
plt.xlim(-0.75,0.75)
plt.ylim(-0.1,0.1)
plt.title("SBS devcie approximation error")
plt.legend()
plt.show()

error_sbs = []
# Maximum error
for i in range(299):
  if abs(x[i] - lim_sbs) <= 0.01:
    e = abs(f_approx[i] - f[i])/f[i]
    error_sbs.append(e)

print(error_sbs)

